export default {
  JSONWriter: {
    indentOutput: {
      elementType: {
        type: 'JSONWriter',
        category: 'WRITER',
        roles: ['writer', 'mutator', 'stepping', 'target'],
        icon: 'json.svg',
      },
      name: 'indentOutput',
      type: 'boolean',
      description: 'Should output JSON be indented and include new lines (pretty printed)?',
      defaultValue: 'false',
      pipelineReference: false,
      docRefTypes: null,
    },
    encoding: {
      elementType: {
        type: 'JSONWriter',
        category: 'WRITER',
        roles: ['writer', 'mutator', 'stepping', 'target'],
        icon: 'json.svg',
      },
      name: 'encoding',
      type: 'String',
      description: 'The output character encoding to use.',
      defaultValue: 'UTF-8',
      pipelineReference: false,
      docRefTypes: null,
    },
  },
  BadTextXMLFilterReader: {
    tags: {
      elementType: {
        type: 'BadTextXMLFilterReader',
        category: 'READER',
        roles: ['reader', 'hasTargets'],
        icon: 'stream.svg',
      },
      name: 'tags',
      type: 'String',
      description:
        'A comma separated list of XML elements between which non-escaped characters will be escaped.',
      defaultValue: '',
      pipelineReference: false,
      docRefTypes: null,
    },
  },
  XMLFragmentParser: {
    textConverter: {
      elementType: {
        type: 'XMLFragmentParser',
        category: 'PARSER',
        roles: ['parser', 'hasCode', 'simple', 'hasTargets', 'stepping', 'mutator'],
        icon: 'xml.svg',
      },
      name: 'textConverter',
      type: 'DocRef',
      description: 'The XML fragment wrapper that should be used to wrap the input XML.',
      defaultValue: '',
      pipelineReference: false,
      docRefTypes: ['TextConverter'],
    },
  },
  ElasticIndexingFilter: {
    index: {
      elementType: {
        type: 'ElasticIndexingFilter',
        category: 'FILTER',
        roles: ['simple', 'hasTargets', 'target'],
        icon: 'ElasticSearch.svg',
      },
      name: 'index',
      type: 'DocRef',
      description: 'The elastic index to send records to.',
      defaultValue: '',
      pipelineReference: false,
      docRefTypes: ['ElasticIndex'],
    },
    idFieldName: {
      elementType: {
        type: 'ElasticIndexingFilter',
        category: 'FILTER',
        roles: ['simple', 'hasTargets', 'target'],
        icon: 'ElasticSearch.svg',
      },
      name: 'idFieldName',
      type: 'String',
      description: 'The field name to use as the unique ID for records.',
      defaultValue: '',
      pipelineReference: false,
      docRefTypes: null,
    },
  },
  RecordCountFilter: {
    countRead: {
      elementType: {
        type: 'RecordCountFilter',
        category: 'FILTER',
        roles: ['hasTargets', 'target'],
        icon: 'recordCount.svg',
      },
      name: 'countRead',
      type: 'boolean',
      description: 'Is this filter counting records read or records written?',
      defaultValue: 'true',
      pipelineReference: false,
      docRefTypes: null,
    },
  },
  RollingFileAppender: {
    fileName: {
      elementType: {
        type: 'RollingFileAppender',
        category: 'DESTINATION',
        roles: ['destination', 'stepping', 'target'],
        icon: 'files.svg',
      },
      name: 'fileName',
      type: 'String',
      description: 'Choose the name of the file to write.',
      defaultValue: '',
      pipelineReference: false,
      docRefTypes: null,
    },
    rolledFileName: {
      elementType: {
        type: 'RollingFileAppender',
        category: 'DESTINATION',
        roles: ['destination', 'stepping', 'target'],
        icon: 'files.svg',
      },
      name: 'rolledFileName',
      type: 'String',
      description: 'Choose the name that files will be renamed to when they are rolled.',
      defaultValue: '',
      pipelineReference: false,
      docRefTypes: null,
    },
    maxSize: {
      elementType: {
        type: 'RollingFileAppender',
        category: 'DESTINATION',
        roles: ['destination', 'stepping', 'target'],
        icon: 'files.svg',
      },
      name: 'maxSize',
      type: 'String',
      description: 'Choose the maximum size that a file can be before it is rolled, e.g. 10M, 1G.',
      defaultValue: '100M',
      pipelineReference: false,
      docRefTypes: null,
    },
    outputPaths: {
      elementType: {
        type: 'RollingFileAppender',
        category: 'DESTINATION',
        roles: ['destination', 'stepping', 'target'],
        icon: 'files.svg',
      },
      name: 'outputPaths',
      type: 'String',
      description:
        'One or more destination paths for output files separated with commas. Replacement variables can be used in path strings such as ${feed}.',
      defaultValue: '',
      pipelineReference: false,
      docRefTypes: null,
    },
    frequency: {
      elementType: {
        type: 'RollingFileAppender',
        category: 'DESTINATION',
        roles: ['destination', 'stepping', 'target'],
        icon: 'files.svg',
      },
      name: 'frequency',
      type: 'String',
      description: 'Choose how frequently files are rolled.',
      defaultValue: '1h',
      pipelineReference: false,
      docRefTypes: null,
    },
  },
  TextWriter: {
    footer: {
      elementType: {
        type: 'TextWriter',
        category: 'WRITER',
        roles: ['hasTargets', 'writer', 'mutator', 'stepping', 'target'],
        icon: 'text.svg',
      },
      name: 'footer',
      type: 'String',
      description: 'Footer text that can be added to the output at the end.',
      defaultValue: '',
      pipelineReference: false,
      docRefTypes: null,
    },
    header: {
      elementType: {
        type: 'TextWriter',
        category: 'WRITER',
        roles: ['hasTargets', 'writer', 'mutator', 'stepping', 'target'],
        icon: 'text.svg',
      },
      name: 'header',
      type: 'String',
      description: 'Header text that can be added to the output at the start.',
      defaultValue: '',
      pipelineReference: false,
      docRefTypes: null,
    },
    encoding: {
      elementType: {
        type: 'TextWriter',
        category: 'WRITER',
        roles: ['hasTargets', 'writer', 'mutator', 'stepping', 'target'],
        icon: 'text.svg',
      },
      name: 'encoding',
      type: 'String',
      description: 'The output character encoding to use.',
      defaultValue: 'UTF-8',
      pipelineReference: false,
      docRefTypes: null,
    },
  },
  StroomStatsFilter: {
    statisticsDataSource: {
      elementType: {
        type: 'StroomStatsFilter',
        category: 'FILTER',
        roles: ['simple', 'hasTargets', 'target'],
        icon: 'StroomStatsStore.svg',
      },
      name: 'statisticsDataSource',
      type: 'DocRef',
      description: 'The stroom-stats data source to record statistics against.',
      defaultValue: '',
      pipelineReference: false,
      docRefTypes: ['StroomStatsStore'],
    },
    flushOnSend: {
      elementType: {
        type: 'StroomStatsFilter',
        category: 'FILTER',
        roles: ['simple', 'hasTargets', 'target'],
        icon: 'StroomStatsStore.svg',
      },
      name: 'flushOnSend',
      type: 'boolean',
      description:
        'Wait for acknowledgement from the Kafka borker for each message sent. This is slower but catches errors sooner',
      defaultValue: 'false',
      pipelineReference: false,
      docRefTypes: null,
    },
  },
  Reader: {},
  TestFilter: {},
  DSParser: {
    textConverter: {
      elementType: {
        type: 'DSParser',
        category: 'PARSER',
        roles: ['parser', 'hasCode', 'simple', 'hasTargets', 'stepping', 'mutator'],
        icon: 'text.svg',
      },
      name: 'textConverter',
      type: 'DocRef',
      description: 'The data splitter configuration that should be used to parse the input data.',
      defaultValue: '',
      pipelineReference: false,
      docRefTypes: ['TextConverter'],
    },
  },
  CombinedParser: {
    textConverter: {
      elementType: {
        type: 'CombinedParser',
        category: 'PARSER',
        roles: ['parser', 'hasCode', 'simple', 'hasTargets', 'stepping', 'mutator'],
        icon: 'text.svg',
      },
      name: 'textConverter',
      type: 'DocRef',
      description: 'The text converter configuration that should be used to parse the input data.',
      defaultValue: '',
      pipelineReference: false,
      docRefTypes: ['TextConverter'],
    },
    fixInvalidChars: {
      elementType: {
        type: 'CombinedParser',
        category: 'PARSER',
        roles: ['parser', 'hasCode', 'simple', 'hasTargets', 'stepping', 'mutator'],
        icon: 'text.svg',
      },
      name: 'fixInvalidChars',
      type: 'boolean',
      description: 'Fix invalid XML characters from the input stream.',
      defaultValue: 'false',
      pipelineReference: false,
      docRefTypes: null,
    },
    type: {
      elementType: {
        type: 'CombinedParser',
        category: 'PARSER',
        roles: ['parser', 'hasCode', 'simple', 'hasTargets', 'stepping', 'mutator'],
        icon: 'text.svg',
      },
      name: 'type',
      type: 'String',
      description: "The parser type, e.g. 'JSON', 'XML', 'Data Splitter'.",
      defaultValue: '',
      pipelineReference: false,
      docRefTypes: null,
    },
  },
  XMLWriter: {
    indentOutput: {
      elementType: {
        type: 'XMLWriter',
        category: 'WRITER',
        roles: ['hasTargets', 'writer', 'mutator', 'stepping', 'target'],
        icon: 'xml.svg',
      },
      name: 'indentOutput',
      type: 'boolean',
      description: 'Should output XML be indented and include new lines (pretty printed)?',
      defaultValue: 'false',
      pipelineReference: false,
      docRefTypes: null,
    },
    encoding: {
      elementType: {
        type: 'XMLWriter',
        category: 'WRITER',
        roles: ['hasTargets', 'writer', 'mutator', 'stepping', 'target'],
        icon: 'xml.svg',
      },
      name: 'encoding',
      type: 'String',
      description: 'The output character encoding to use.',
      defaultValue: 'UTF-8',
      pipelineReference: false,
      docRefTypes: null,
    },
  },
  Source: {},
  SplitFilter: {
    splitDepth: {
      elementType: {
        type: 'SplitFilter',
        category: 'FILTER',
        roles: ['hasTargets', 'target'],
        icon: 'split.svg',
      },
      name: 'splitDepth',
      type: 'int',
      description: 'The depth of XML elements to split at.',
      defaultValue: '1',
      pipelineReference: false,
      docRefTypes: null,
    },
    splitCount: {
      elementType: {
        type: 'SplitFilter',
        category: 'FILTER',
        roles: ['hasTargets', 'target'],
        icon: 'split.svg',
      },
      name: 'splitCount',
      type: 'int',
      description: 'The number of elements at the split depth to count before the XML is split.',
      defaultValue: '10000',
      pipelineReference: false,
      docRefTypes: null,
    },
  },
  InvalidCharFilterReader: {},
  HttpPostFilter: {
    receivingApiUrl: {
      elementType: {
        type: 'HttpPostFilter',
        category: 'FILTER',
        roles: ['simple', 'hasTargets', 'target'],
        icon: 'stream.svg',
      },
      name: 'receivingApiUrl',
      type: 'String',
      description: 'The URL of the receiving API.',
      defaultValue: '',
      pipelineReference: false,
      docRefTypes: null,
    },
  },
  RollingKafkaAppender: {
    recordKey: {
      elementType: {
        type: 'RollingKafkaAppender',
        category: 'DESTINATION',
        roles: ['destination', 'stepping', 'target'],
        icon: 'apache_kafka-icon.svg',
      },
      name: 'recordKey',
      type: 'String',
      description:
        'The record key to apply to records, used to select partition. Replacement variables can be used in path strings such as ${feed}.',
      defaultValue: '',
      pipelineReference: false,
      docRefTypes: null,
    },
    topic: {
      elementType: {
        type: 'RollingKafkaAppender',
        category: 'DESTINATION',
        roles: ['destination', 'stepping', 'target'],
        icon: 'apache_kafka-icon.svg',
      },
      name: 'topic',
      type: 'String',
      description:
        'The topic to send the record to. Replacement variables can be used in path strings such as ${feed}.',
      defaultValue: '',
      pipelineReference: false,
      docRefTypes: null,
    },
    maxSize: {
      elementType: {
        type: 'RollingKafkaAppender',
        category: 'DESTINATION',
        roles: ['destination', 'stepping', 'target'],
        icon: 'apache_kafka-icon.svg',
      },
      name: 'maxSize',
      type: 'String',
      description: 'Choose the maximum size that a file can be before it is rolled, e.g. 10M, 1G.',
      defaultValue: '100M',
      pipelineReference: false,
      docRefTypes: null,
    },
    flushOnSend: {
      elementType: {
        type: 'RollingKafkaAppender',
        category: 'DESTINATION',
        roles: ['destination', 'stepping', 'target'],
        icon: 'apache_kafka-icon.svg',
      },
      name: 'flushOnSend',
      type: 'boolean',
      description:
        'Wait for acknowledgement from the Kafka broker when the appender is rolledThis is slower but catches errors in the pipeline process',
      defaultValue: 'false',
      pipelineReference: false,
      docRefTypes: null,
    },
    frequency: {
      elementType: {
        type: 'RollingKafkaAppender',
        category: 'DESTINATION',
        roles: ['destination', 'stepping', 'target'],
        icon: 'apache_kafka-icon.svg',
      },
      name: 'frequency',
      type: 'String',
      description: 'Choose how frequently files are rolled.',
      defaultValue: '1h',
      pipelineReference: false,
      docRefTypes: null,
    },
  },
  TestAppender: {},
  KafkaAppender: {
    recordKey: {
      elementType: {
        type: 'KafkaAppender',
        category: 'DESTINATION',
        roles: ['destination', 'stepping', 'target'],
        icon: 'apache_kafka-icon.svg',
      },
      name: 'recordKey',
      type: 'String',
      description: 'This key to apply to the records, used to select partition.',
      defaultValue: '',
      pipelineReference: false,
      docRefTypes: null,
    },
    maxRecordCount: {
      elementType: {
        type: 'KafkaAppender',
        category: 'DESTINATION',
        roles: ['destination', 'stepping', 'target'],
        icon: 'apache_kafka-icon.svg',
      },
      name: 'maxRecordCount',
      type: 'String',
      description: 'Choose the maximum number of records or events that a message will contain',
      defaultValue: '1',
      pipelineReference: false,
      docRefTypes: null,
    },
    topic: {
      elementType: {
        type: 'KafkaAppender',
        category: 'DESTINATION',
        roles: ['destination', 'stepping', 'target'],
        icon: 'apache_kafka-icon.svg',
      },
      name: 'topic',
      type: 'String',
      description: 'The topic to send the record to.',
      defaultValue: '',
      pipelineReference: false,
      docRefTypes: null,
    },
    flushOnSend: {
      elementType: {
        type: 'KafkaAppender',
        category: 'DESTINATION',
        roles: ['destination', 'stepping', 'target'],
        icon: 'apache_kafka-icon.svg',
      },
      name: 'flushOnSend',
      type: 'boolean',
      description:
        'Wait for acknowledgement from the Kafka broker for all of the messages sent.This is slower but catches errors in the pipeline process',
      defaultValue: 'false',
      pipelineReference: false,
      docRefTypes: null,
    },
  },
  XSLTFilter: {
    suppressXSLTNotFoundWarnings: {
      elementType: {
        type: 'XSLTFilter',
        category: 'FILTER',
        roles: ['hasCode', 'simple', 'hasTargets', 'stepping', 'mutator', 'target'],
        icon: 'xslt.svg',
      },
      name: 'suppressXSLTNotFoundWarnings',
      type: 'boolean',
      description: 'If XSLT cannot be found to match the name pattern suppress warnings.',
      defaultValue: 'false',
      pipelineReference: false,
      docRefTypes: null,
    },
    usePool: {
      elementType: {
        type: 'XSLTFilter',
        category: 'FILTER',
        roles: ['hasCode', 'simple', 'hasTargets', 'stepping', 'mutator', 'target'],
        icon: 'xslt.svg',
      },
      name: 'usePool',
      type: 'boolean',
      description:
        'Advanced: Choose whether or not you want to use cached XSLT templates to improve performance.',
      defaultValue: 'true',
      pipelineReference: false,
      docRefTypes: null,
    },
    pipelineReference: {
      elementType: {
        type: 'XSLTFilter',
        category: 'FILTER',
        roles: ['hasCode', 'simple', 'hasTargets', 'stepping', 'mutator', 'target'],
        icon: 'xslt.svg',
      },
      name: 'pipelineReference',
      type: 'PipelineReference',
      description: 'A list of places to load reference data from if required.',
      defaultValue: '',
      pipelineReference: true,
      docRefTypes: null,
    },
    xslt: {
      elementType: {
        type: 'XSLTFilter',
        category: 'FILTER',
        roles: ['hasCode', 'simple', 'hasTargets', 'stepping', 'mutator', 'target'],
        icon: 'xslt.svg',
      },
      name: 'xslt',
      type: 'DocRef',
      description: 'The XSLT to use.',
      defaultValue: '',
      pipelineReference: false,
      docRefTypes: ['XSLT'],
    },
    xsltNamePattern: {
      elementType: {
        type: 'XSLTFilter',
        category: 'FILTER',
        roles: ['hasCode', 'simple', 'hasTargets', 'stepping', 'mutator', 'target'],
        icon: 'xslt.svg',
      },
      name: 'xsltNamePattern',
      type: 'String',
      description: 'A name pattern to load XSLT dynamically.',
      defaultValue: '',
      pipelineReference: false,
      docRefTypes: null,
    },
  },
  StreamAppender: {
    feed: {
      elementType: {
        type: 'StreamAppender',
        category: 'DESTINATION',
        roles: ['destination', 'stepping', 'target'],
        icon: 'stream.svg',
      },
      name: 'feed',
      type: 'DocRef',
      description:
        'The feed that output stream should be written to. If not specified the feed the input stream belongs to will be used.',
      defaultValue: '',
      pipelineReference: false,
      docRefTypes: ['Feed'],
    },
    segmentOutput: {
      elementType: {
        type: 'StreamAppender',
        category: 'DESTINATION',
        roles: ['destination', 'stepping', 'target'],
        icon: 'stream.svg',
      },
      name: 'segmentOutput',
      type: 'boolean',
      description:
        'Should the output stream be marked with indexed segments to allow fast access to individual records?',
      defaultValue: 'true',
      pipelineReference: false,
      docRefTypes: null,
    },
    streamType: {
      elementType: {
        type: 'StreamAppender',
        category: 'DESTINATION',
        roles: ['destination', 'stepping', 'target'],
        icon: 'stream.svg',
      },
      name: 'streamType',
      type: 'String',
      description:
        'The stream type that the output stream should be written as. This must be specified.',
      defaultValue: '',
      pipelineReference: false,
      docRefTypes: null,
    },
  },
  RecordOutputFilter: {},
  XMLParser: {},
  HDFSFileAppender: {
    runAsUser: {
      elementType: {
        type: 'HDFSFileAppender',
        category: 'DESTINATION',
        roles: ['destination', 'stepping', 'target'],
        icon: 'hadoop-elephant-logo.svg',
      },
      name: 'runAsUser',
      type: 'String',
      description: 'The user to connect to HDFS as',
      defaultValue: '',
      pipelineReference: false,
      docRefTypes: null,
    },
    fileSystemUri: {
      elementType: {
        type: 'HDFSFileAppender',
        category: 'DESTINATION',
        roles: ['destination', 'stepping', 'target'],
        icon: 'hadoop-elephant-logo.svg',
      },
      name: 'fileSystemUri',
      type: 'String',
      description:
        'URI for the Hadoop Distributed File System (HDFS) to connect to, e.g. hdfs://mynamenode.mydomain.com:8020',
      defaultValue: '',
      pipelineReference: false,
      docRefTypes: null,
    },
    outputPaths: {
      elementType: {
        type: 'HDFSFileAppender',
        category: 'DESTINATION',
        roles: ['destination', 'stepping', 'target'],
        icon: 'hadoop-elephant-logo.svg',
      },
      name: 'outputPaths',
      type: 'String',
      description:
        'One or more destination paths for output files separated with commas. Replacement variables can be used in path strings such as ${feed}.',
      defaultValue: '',
      pipelineReference: false,
      docRefTypes: null,
    },
  },
  SearchResultOutputFilter: {},
  FileAppender: {
    outputPaths: {
      elementType: {
        type: 'FileAppender',
        category: 'DESTINATION',
        roles: ['destination', 'stepping', 'target'],
        icon: 'file.svg',
      },
      name: 'outputPaths',
      type: 'String',
      description:
        'One or more destination paths for output files separated with commas. Replacement variables can be used in path strings such as ${feed}.',
      defaultValue: '',
      pipelineReference: false,
      docRefTypes: null,
    },
  },
  ReferenceDataFilter: {
    warnOnDuplicateKeys: {
      elementType: {
        type: 'ReferenceDataFilter',
        category: 'FILTER',
        roles: ['hasTargets', 'target'],
        icon: 'referenceData.svg',
      },
      name: 'warnOnDuplicateKeys',
      type: 'boolean',
      description: 'Warn if there are duplicate keys found in the reference data?',
      defaultValue: 'false',
      pipelineReference: false,
      docRefTypes: null,
    },
    overrideExistingValues: {
      elementType: {
        type: 'ReferenceDataFilter',
        category: 'FILTER',
        roles: ['hasTargets', 'target'],
        icon: 'referenceData.svg',
      },
      name: 'overrideExistingValues',
      type: 'boolean',
      description: 'Allow duplicate keys to override existing values?',
      defaultValue: 'true',
      pipelineReference: false,
      docRefTypes: null,
    },
  },
  InvalidXMLCharFilterReader: {
    xmlVersion: {
      elementType: {
        type: 'InvalidXMLCharFilterReader',
        category: 'READER',
        roles: ['reader', 'hasTargets'],
        icon: 'stream.svg',
      },
      name: 'xmlVersion',
      type: 'String',
      description: 'XML version, e.g. 1.0 or 1.1',
      defaultValue: '1.1',
      pipelineReference: false,
      docRefTypes: null,
    },
  },
  IdEnrichmentFilter: {},
  HTTPAppender: {
    logMetaKeys: {
      elementType: {
        type: 'HTTPAppender',
        category: 'DESTINATION',
        roles: ['destination', 'stepping', 'target'],
        icon: 'stream.svg',
      },
      name: 'logMetaKeys',
      type: 'String',
      description: 'Which meta data values will be logged in the send log',
      defaultValue: 'guid,feed,system,environment,remotehost,remoteaddress',
      pipelineReference: false,
      docRefTypes: null,
    },
    forwardChunkSize: {
      elementType: {
        type: 'HTTPAppender',
        category: 'DESTINATION',
        roles: ['destination', 'stepping', 'target'],
        icon: 'stream.svg',
      },
      name: 'forwardChunkSize',
      type: 'String',
      description: 'Should data be sent in chunks and if so how big should the chunks be',
      defaultValue: '',
      pipelineReference: false,
      docRefTypes: null,
    },
    forwardUrl: {
      elementType: {
        type: 'HTTPAppender',
        category: 'DESTINATION',
        roles: ['destination', 'stepping', 'target'],
        icon: 'stream.svg',
      },
      name: 'forwardUrl',
      type: 'String',
      description: 'The URL to send data to',
      defaultValue: '',
      pipelineReference: false,
      docRefTypes: null,
    },
    useCompression: {
      elementType: {
        type: 'HTTPAppender',
        category: 'DESTINATION',
        roles: ['destination', 'stepping', 'target'],
        icon: 'stream.svg',
      },
      name: 'useCompression',
      type: 'boolean',
      description: 'Should data be compressed when sending',
      defaultValue: 'true',
      pipelineReference: false,
      docRefTypes: null,
    },
    connectionTimeout: {
      elementType: {
        type: 'HTTPAppender',
        category: 'DESTINATION',
        roles: ['destination', 'stepping', 'target'],
        icon: 'stream.svg',
      },
      name: 'connectionTimeout',
      type: 'String',
      description: 'How long to wait before we abort sending data due to connection timeout',
      defaultValue: '',
      pipelineReference: false,
      docRefTypes: null,
    },
  },
  SchemaFilter: {
    systemId: {
      elementType: {
        type: 'SchemaFilter',
        category: 'FILTER',
        roles: ['validator', 'hasTargets', 'stepping', 'target'],
        icon: 'xsd.svg',
      },
      name: 'systemId',
      type: 'String',
      description:
        'Limits the schemas that can be used to validate data to those with a matching system id.',
      defaultValue: '',
      pipelineReference: false,
      docRefTypes: null,
    },
    schemaValidation: {
      elementType: {
        type: 'SchemaFilter',
        category: 'FILTER',
        roles: ['validator', 'hasTargets', 'stepping', 'target'],
        icon: 'xsd.svg',
      },
      name: 'schemaValidation',
      type: 'boolean',
      description: 'Should schema validation be performed?',
      defaultValue: 'true',
      pipelineReference: false,
      docRefTypes: null,
    },
    namespaceURI: {
      elementType: {
        type: 'SchemaFilter',
        category: 'FILTER',
        roles: ['validator', 'hasTargets', 'stepping', 'target'],
        icon: 'xsd.svg',
      },
      name: 'namespaceURI',
      type: 'String',
      description:
        'Limits the schemas that can be used to validate data to those with a matching namespace URI.',
      defaultValue: '',
      pipelineReference: false,
      docRefTypes: null,
    },
    schemaLanguage: {
      elementType: {
        type: 'SchemaFilter',
        category: 'FILTER',
        roles: ['validator', 'hasTargets', 'stepping', 'target'],
        icon: 'xsd.svg',
      },
      name: 'schemaLanguage',
      type: 'String',
      description: 'The schema language that the schema is written in.',
      defaultValue: 'http://www.w3.org/2001/XMLSchema',
      pipelineReference: false,
      docRefTypes: null,
    },
    schemaGroup: {
      elementType: {
        type: 'SchemaFilter',
        category: 'FILTER',
        roles: ['validator', 'hasTargets', 'stepping', 'target'],
        icon: 'xsd.svg',
      },
      name: 'schemaGroup',
      type: 'String',
      description:
        'Limits the schemas that can be used to validate data to those with a matching schema group name.',
      defaultValue: '',
      pipelineReference: false,
      docRefTypes: null,
    },
  },
  IndexingFilter: {
    index: {
      elementType: {
        type: 'IndexingFilter',
        category: 'FILTER',
        roles: ['simple', 'hasTargets', 'target'],
        icon: 'index.svg',
      },
      name: 'index',
      type: 'DocRef',
      description: 'The index to send records to.',
      defaultValue: '',
      pipelineReference: false,
      docRefTypes: ['Index'],
    },
  },
  BOMRemovalFilterInput: {},
  StroomStatsAppender: {
    maxRecordCount: {
      elementType: {
        type: 'StroomStatsAppender',
        category: 'DESTINATION',
        roles: ['destination', 'stepping', 'target'],
        icon: 'StroomStatsStore.svg',
      },
      name: 'maxRecordCount',
      type: 'String',
      description: 'Choose the maximum number of records or events that a message will contain',
      defaultValue: '1',
      pipelineReference: false,
      docRefTypes: null,
    },
    statisticsDataSource: {
      elementType: {
        type: 'StroomStatsAppender',
        category: 'DESTINATION',
        roles: ['destination', 'stepping', 'target'],
        icon: 'StroomStatsStore.svg',
      },
      name: 'statisticsDataSource',
      type: 'DocRef',
      description: 'The stroom-stats data source to record statistics against.',
      defaultValue: '',
      pipelineReference: false,
      docRefTypes: ['StroomStatsStore'],
    },
    flushOnSend: {
      elementType: {
        type: 'StroomStatsAppender',
        category: 'DESTINATION',
        roles: ['destination', 'stepping', 'target'],
        icon: 'StroomStatsStore.svg',
      },
      name: 'flushOnSend',
      type: 'boolean',
      description:
        'Wait for acknowledgement from the Kafka broker for all of the messages sent.This is slower but catches errors in the pipeline process',
      defaultValue: 'false',
      pipelineReference: false,
      docRefTypes: null,
    },
  },
  RollingStreamAppender: {
    feed: {
      elementType: {
        type: 'RollingStreamAppender',
        category: 'DESTINATION',
        roles: ['destination', 'stepping', 'target'],
        icon: 'stream.svg',
      },
      name: 'feed',
      type: 'DocRef',
      description:
        'The feed that output stream should be written to. If not specified the feed the input stream belongs to will be used.',
      defaultValue: '',
      pipelineReference: false,
      docRefTypes: ['Feed'],
    },
    segmentOutput: {
      elementType: {
        type: 'RollingStreamAppender',
        category: 'DESTINATION',
        roles: ['destination', 'stepping', 'target'],
        icon: 'stream.svg',
      },
      name: 'segmentOutput',
      type: 'boolean',
      description:
        'Shoud the output stream be marked with indexed segments to allow fast access to individual records?',
      defaultValue: 'true',
      pipelineReference: false,
      docRefTypes: null,
    },
    streamType: {
      elementType: {
        type: 'RollingStreamAppender',
        category: 'DESTINATION',
        roles: ['destination', 'stepping', 'target'],
        icon: 'stream.svg',
      },
      name: 'streamType',
      type: 'String',
      description:
        'The stream type that the output stream should be written as. This must be specified.',
      defaultValue: '',
      pipelineReference: false,
      docRefTypes: null,
    },
    maxSize: {
      elementType: {
        type: 'RollingStreamAppender',
        category: 'DESTINATION',
        roles: ['destination', 'stepping', 'target'],
        icon: 'stream.svg',
      },
      name: 'maxSize',
      type: 'String',
      description: 'Choose the maximum size that a file can be before it is rolled, e.g. 10M, 1G.',
      defaultValue: '100M',
      pipelineReference: false,
      docRefTypes: null,
    },
    frequency: {
      elementType: {
        type: 'RollingStreamAppender',
        category: 'DESTINATION',
        roles: ['destination', 'stepping', 'target'],
        icon: 'stream.svg',
      },
      name: 'frequency',
      type: 'String',
      description: 'Choose how frequently files are rolled.',
      defaultValue: '1h',
      pipelineReference: false,
      docRefTypes: null,
    },
  },
  JSONParser: {},
  GenericKafkaProducerFilter: {
    recordKey: {
      elementType: {
        type: 'GenericKafkaProducerFilter',
        category: 'FILTER',
        roles: ['simple', 'hasTargets', 'target'],
        icon: 'apache_kafka-icon.svg',
      },
      name: 'recordKey',
      type: 'String',
      description: 'This key to apply to the records, used to select partition.',
      defaultValue: '',
      pipelineReference: false,
      docRefTypes: null,
    },
    topic: {
      elementType: {
        type: 'GenericKafkaProducerFilter',
        category: 'FILTER',
        roles: ['simple', 'hasTargets', 'target'],
        icon: 'apache_kafka-icon.svg',
      },
      name: 'topic',
      type: 'String',
      description: 'The topic to send the record to.',
      defaultValue: '',
      pipelineReference: false,
      docRefTypes: null,
    },
    flushOnSend: {
      elementType: {
        type: 'GenericKafkaProducerFilter',
        category: 'FILTER',
        roles: ['simple', 'hasTargets', 'target'],
        icon: 'apache_kafka-icon.svg',
      },
      name: 'flushOnSend',
      type: 'boolean',
      description:
        'Wait for acknowledgement from the Kafka borker for each message sent. This is slower but catches errors sooner',
      defaultValue: 'false',
      pipelineReference: false,
      docRefTypes: null,
    },
  },
};
