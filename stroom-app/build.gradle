buildscript {
    repositories {
        mavenLocal()
        jcenter()
    }
    dependencies {
        classpath libs.mysql_connector_java
    }
}

plugins {
    //id 'com.github.johnrengelman.shadow' version '2.0.0'
    id "com.benjaminsproule.swagger" version "0.1.9"

    //plugin to generate a list of licennces for all deps and to check for incompatibilities
    //usage: honkerCheck honkerGenNotice honkerGenDependencies
    //search for NOTICE.txt and DEPENDENCIES.txt
    //id "org.nosphere.honker" version "0.3.0"
    id 'org.flywaydb.flyway' version '5.0.7'
    id "de.undercouch.download"
}

def uiDir = project.file('src/main/resources/ui')
def swaggerDir = "${uiDir}/swagger"
def jarName = 'stroom-app.jar'
def fatJarName = 'stroom-app-all.jar'
def sendToStroomScriptVersion = 'send-to-stroom-v2.0'

apply plugin: 'application'
apply plugin: 'com.github.johnrengelman.shadow'
mainClassName = 'stroom.startup.App'

jar {
    //we need to first generate the swagger spec files so they can be added in to the jar
    mustRunAfter generateSwaggerDocumentation

    manifest {
        attributes(
                "Implementation-Title": "Stroom",
                "Implementation-Version": versions.stroom,
                "Main-Class" : "stroom.startup.App"
        )
    }
    archiveName jarName

    exclude '**/gwt-unitCache'
}

import com.github.jengelman.gradle.plugins.shadow.transformers.ServiceFileTransformer

shadowJar {
    // Allows us to build fat jars with lots of files
    zip64 true

    // A transformer to merges files in META-INF/services
    mergeServiceFiles()

    // A transformer to merge spring's generated config files, e.g. spring.handlers and spring.schemas
    transform(ServiceFileTransformer) {
        include 'META-INF/spring.*'
    }
    archiveName fatJarName

    exclude '**/gwt-unitCache'
}

dependencies {
    compile project(':stroom-core-shared')
    compile project(':stroom-core-server')
    compile project(':stroom-pipeline')
    compile project(':stroom-proxy')
    compile project(':stroom-explorer-api')
    compile project(':stroom-explorer-server')
    compile project(':stroom-security-server')
    compile project(':stroom-util')
    permitUnusedDeclared project(':stroom-security-server') //not clear why it thinks this is unused
    compile project(':stroom-index-server')
    compile project(':stroom-statistics-api')
    permitUnusedDeclared project(':stroom-statistics-api') //not clear why it thinks this is unused
    compile project(':stroom-entity-shared')
    permitUnusedDeclared project(':stroom-entity-shared') //not clear why it thinks this is unused
    compile project(':stroom-index-shared')
    permitUnusedDeclared project(':stroom-index-shared') // not clear why it thinks this is unused
//    compile project(':stroom-util')
    compile project(':stroom-pipeline')
    compile project(':stroom-dashboard-server')
    compile project(':stroom-statistics-server')
    compile project(':stroom-externaldoc-server')
    compile project(':stroom-elastic-server')
    compile project(':stroom-ruleset-server')

    compile libs.stroomQueryApi

    compile libs.dropwizard_lifecycle
    compile libs.guava
    compile libs.guice3
    compile libs.jackson_annotations
    compile libs.javax_inject
    compile libs.jcommander
    compile libs.jetty_servlet
    compile libs.spring_core
    compile libs.spring_beans
    compile libs.spring_context
    permitUnusedDeclared libs.spring_aspects
    compile libs.spring_aspects

    compile (libs.dropwizard_assets) {
        exclude ( group: "org.glassfish.web", module: "javax.el" )
    }
    compile (libs.dropwizard_core) {
        exclude ( group: "org.glassfish.web", module: "javax.el" )
    }
    compile libs.dropwizard_jersey
    compile libs.dropwizard_jetty
    compile libs.dropwizard_metrics_healthchecks
    compile libs.dropwizard_servlets
    compile libs.dropwizard_metrics_annotation
    compile libs.dropwizard_configuration
    compile libs.flyway_core
    compile libs.guava
//    compile libs.jackson_annotations
    compile libs.javax_inject
    compile libs.javax_servlet_api
//    compile libs.javax_validation
    compile libs.javax_servlet_api
    compile libs.jetty_server
    compile libs.jetty_servlets
    compile libs.logback_classic
    compile libs.slf4j_api
    compile libs.ws_rs_api

    runtime libs.javax_el
    runtime libs.javax_el_api
}

run {
    //Ensure we have the latest kafka plugin jar available for runtime
    dependsOn ':stroom-kafka-client-impl_0_10_0_1:copyPluginJar'
    args 'server', './dev.yml'
}

runShadow {
    //Ensure we have the latest kafka plugin jar available for runtime
    dependsOn ':stroom-kafka-client-impl_0_10_0_1:copyPluginJar'
    args 'server', './dev.yml'
}

//The gwtCompile tasks create files in stroom-app/src/main/resources/ui
//so those tasks MUST be run before processResource else this jar and 
//the fat jar will be missing all the GWT generated files and the UI will fail to start
processResources.mustRunAfter(':stroom-app-gwt:gwtCompile')
processResources.mustRunAfter(':stroom-dashboard-gwt:gwtCompile')

def stroomDockerBuildDir = "${projectDir}/docker/build"
def proxyDockerBuildDir = "${projectDir}/proxy-docker/build"

clean{
    delete stroomDockerBuildDir
    delete proxyDockerBuildDir
}

//Copy all the files needed by the stroom docker build into stroom-app/docker/build
task copyFilesForStroomDockerBuild() {
    dependsOn shadowJar
    dependsOn parent.downloadStroomContent
    dependsOn tasks.getByPath(':stroom-kafka-client-impl_0_10_0_1:shadowJar')
    dependsOn tasks.getByPath(':stroom-elastic-client-impl_5_6_4:shadowJar')

    doFirst {
        new File(stroomPluginsDir).mkdirs()
        def stroomDockerContentPacksDir = "${stroomDockerBuildDir}/contentPacks"
        def stroomDockerPluginsDir = "${stroomDockerBuildDir}/plugins"
        new File(stroomPluginsDir).mkdirs()

        //Copy the stroom app fat jar
        copy {
            from "${project.buildDir}/libs/${fatJarName}"
            into stroomDockerBuildDir
        }

        //Copy the kafka client fat jar
        copy {
            from project(':stroom-kafka-client-impl_0_10_0_1').file('build/libs/stroom-kafka-client-impl_0_10_0_1-all.jar')
            into stroomDockerPluginsDir
        }

        //Copy the elastic client fat jar
        copy {
            from project(':stroom-elastic-client-impl_5_6_4').file('build/libs/stroom-elastic-client-impl_5_6_4-all.jar')
            into stroomDockerPluginsDir
        }

        //Copy the dropwizard yml configuration
        copy {
            from "${projectDir}/prod.yml"
            into stroomDockerBuildDir
        }

        //Copy the downloaded content packs
        copy {
            from "${contentPackDownloadDir}"
            into stroomDockerContentPacksDir
        }
    }
}

//Copy all the files needed by the stroom-proxy docker build into stroom-app/proxy-docker/build
task copyFilesForProxyDockerBuild() {
    dependsOn shadowJar
    doFirst {
        //Copy the stroom app fat jar
        copy {
            from "${project.buildDir}/libs/${fatJarName}"
            into proxyDockerBuildDir
        }

        //Copy the dropwizard yml configuration
        copy {
            from "${projectDir}/proxy-prod.yml"
            into proxyDockerBuildDir
        }
    }
}

swagger {
    apiSource {
        springmvc = false //makes it search for jersey annotations
        outputFormats = 'json,yaml'
        locations = [
                'stroom.statistics.server.sql.search.SqlStatisticsQueryResource',
                'stroom.index.server.StroomIndexQueryResource',
                'stroom.security.server.AuthorisationResource' ]
        schemes = [
                'http',
                'https' ]
        host = 'localhost:8080'
        basePath = '/api'
        info {
            title = 'stroom API'
            version = 'v1'
            description = 'Various APIs for interacting with stroom and its data'
            contact {
                name = 'GCHQ'
                url = 'https://github.com/gchq/stroom'
            }
            license {
                url = 'http://www.apache.org/licenses/LICENSE-2.0.html'
                name = 'Apache 2.0'
            }
        }
        outputPath = "${swaggerDir}/document.html"
        swaggerDirectory = "${swaggerDir}"
    }
}


def releaseBuildDir= 'build/release'

task copyJar(type: Copy) {
    from shadowJar.outputs.files
    into "${releaseBuildDir}/bin"
}

task copySupportingFiles(type: Copy) {
    from 'src/dist'
    into releaseBuildDir 
}

import de.undercouch.gradle.tasks.download.Download

task downloadSend(type: Download) {
    src "http://raw.githubusercontent.com/gchq/stroom-clients/${sendToStroomScriptVersion}/bash/send_to_stroom.sh"
    dest "${releaseBuildDir}/bin"
}

task downloadSendArgs(type: Download) {
    src "https://raw.githubusercontent.com/gchq/stroom-clients/${sendToStroomScriptVersion}/bash/send_to_stroom_args.sh"
    dest "${releaseBuildDir}/bin"
}

task makeSendExecutable {
    dependsOn copySupportingFiles
    doLast{
        exec {
            commandLine 'chmod', '+x', "${releaseBuildDir}/bin/send_to_stroom.sh"
        }
        exec {
            commandLine 'chmod', '+x', "${releaseBuildDir}/bin/send_to_stroom_args.sh"
        }
    }
}

task copyContentPackToDistribution(type: Copy) {
    from contentPackDownloadDir
    into "${releaseBuildDir}/contentPacks"
}

task buildDistribution(type: Zip) {
    dependsOn copyJar
    dependsOn copySupportingFiles
    dependsOn downloadSend
    dependsOn downloadSendArgs
    dependsOn makeSendExecutable
    dependsOn parent.downloadStroomContent
    dependsOn copyContentPackToDistribution
    from releaseBuildDir
}



tasks.build.dependsOn generateSwaggerDocumentation
tasks.build.dependsOn copyFilesForStroomDockerBuild
tasks.build.dependsOn copyFilesForProxyDockerBuild
tasks.build.dependsOn shadowJar
tasks.build.dependsOn buildDistribution

//commented out in case we decide to use this plugin
//honker {
    //// Your project license
    //license 'Apache 2'

    //// Your project information, used to generate NOTICE files
    //projectName 'Stroom'
    //projectTimespan '2016-2017'
    //projectOrganization 'GCHQ'

    //// For dependencies that contains no licensing information (pom, manifest etc..)
    //// you can define your licensing strategy, for example:
    ////licenseOverride { candidate ->
        ////if( candidate.group == 'something' && candidate.module == 'whatever' ) {
            ////candidate.license = 'BSD 3-Clause'
        ////}
    ////}
//}
