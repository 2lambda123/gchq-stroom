plugins {
  id 'com.github.johnrengelman.shadow' version '1.2.4'
}

apply plugin: 'application'
mainClassName = 'stroom.startup.App'

jar {
    manifest {
        attributes(
                "Implementation-Title": "Stroom",
                "Implementation-Version": version,
                "Main-Class" : "stroom.startup.App"
        )
    }
    archiveName 'stroom-app.jar'
}

import com.github.jengelman.gradle.plugins.shadow.transformers.ServiceFileTransformer

shadowJar {
    // Allows us to build fat jars with lots of files
    zip64 true

    // A transformer to merges files in META-INF/services
    mergeServiceFiles()

    // A transformer to merge spring's generated config files, e.g. spring.handlers and spring.schemas
    transform(ServiceFileTransformer) {
        include 'META-INF/spring.*'
    }
    archiveName 'stroom-app-all.jar'
}

configurations {
    all {
        resolutionStrategy.eachDependency { DependencyResolveDetails details ->
            if (details.requested.name == 'log4j') {
                details.useTarget "org.slf4j:log4j-over-slf4j:1.7.5"
            }
        }
        exclude group: "org.slf4j", module: "slf4j-log4j12"
        exclude group: "log4j", module: "log4j"
    }

    // This means our integration tests get all the dependencies from our tests and we don't need to specify them twice.
    integrationTestCompile.extendsFrom testCompile
    integrationTestRuntime.extendsFrom testRuntime
}

dependencies {

    compile project(':stroom-core-server')
    compile project(':stroom-security-server')
    compile project(':stroom-index-server')
    compile project(':stroom-statistics-api')
    permitUnusedDeclared project(':stroom-statistics-api') //not clear why it thinks this is unused
    compile project(':stroom-entity-shared')
    compile project(':stroom-index-shared')
    compile project(':stroom-util')
    compile project(':stroom-security-api')

    runtime project(':stroom-dashboard-server')
    runtime project(':stroom-statistics-server')

    compile urlDependencies.get(versions.stroomQueryApi)
    compile urlDependencies.get(versions.stroomQueryCommon)

    compile libs.curator_client //#'org.apache.curator:curator_client:2.11.0'
    compile libs.curator_framework //#'org.apache.curator:curator_framework:2.11.0'
    compile libs.curator_x_discovery //#'org.apache.curator:curator_x_discovery:2.11.0'
    compile (libs.dropwizard_assets) {
        exclude ( group: "org.glassfish.web", module: "javax.el" )
    }
    compile (libs.dropwizard_core) {
        exclude ( group: "org.glassfish.web", module: "javax.el" )
    }
    compile libs.dropwizard_jersey //#'io.dropwizard:dropwizard-jersey:1.0.6'
    compile libs.dropwizard_jetty //#'io.dropwizard:dropwizard-jetty:1.0.6'
    compile libs.dropwizard_metrics_annotation //#'io.dropwizard.metrics:metrics-annotation:3.1.2'
    compile libs.dropwizard_metrics_healthchecks //#'io.dropwizard.metrics:metrics_healthchecks:3.1.2'
    compile libs.guava //#'com.google.guava:guava:20.0'
    compile libs.jackson_annotations //#'com.fasterxml.jackson.core:jackson-annotations:2.8.6'
    compile libs.javax_inject //#'javax.inject:javax.inject:1'
    compile libs.javax_servlet_api //#'javax.servlet:javax.servlet_api:3.1.0'
    compile libs.jersey_server //#'org.glassfish.jersey.core:jersey-server:2.25'
    compile libs.jetty_server //#'org.eclipse.jetty:jetty-server:9.3.9.v20160517'
    compile libs.jetty_servlet //#'org.eclipse.jetty:jetty-servlet:9.3.9.v20160517'
    compile libs.shiro_core //#'org.apache.shiro:shiro-core:1.3.2'
    compile libs.slf4j_api //#'org.slf4j:slf4j-api:1.7.24'
    compile libs.spring_beans //#'org.springframework:spring-beans:4.3.4.RELEASE'
    compile libs.spring_context //#'org.springframework:spring_context:4.3.4.RELEASE'
    compile libs.spring_web //#'org.springframework:spring_web:4.2.1.RELEASE'
    compile libs.ws_rs_api //#'javax.ws.rs:javax.ws.rs_api:2.0.1'

    runtime libs.shiro_web //#'org.apache.shiro:shiro-web:1.3.2'
    runtime libs.javax_el
    runtime libs.javax_el_api

    integrationTestCompile libs.junit //#'junit:junit:4.12'
    integrationTestCompile libs.mockito_core //#'org.mockito:mockito-core:2.0.2-beta'
    integrationTestCompile libs.assertj_core //#'org.assertj:assertj-core:3.6.2'
    integrationTestCompile libs.dropwizard_testing //#'io.dropwizard:dropwizard-testing:1.1.0'
    integrationTestCompile libs.dropwizard_client //#'io.dropwizard:dropwizard-client:1.1.0'
}

sourceSets {
    // This lets us use different directories for our integration tests.
    integrationTest {
        java {
            compileClasspath += main.output + test.output
            runtimeClasspath += main.output + test.output
            srcDir file('src/integrationTest/java')
        }
        resources.srcDir file('src/integrationTest/resources')
    }
}



// This task lets us run the actual integration tests.
task integrationTest(type: Test) {
    testClassesDir = sourceSets.integrationTest.output.classesDir
    classpath = sourceSets.integrationTest.runtimeClasspath
}

// TODO: Integration tests currently require manual setup of resources, which means hey cannot be included in the build as automated tests.
// These lines pull the integration test task into our build process.
//check.dependsOn integrationTest
//integrationTest.mustRunAfter test

// This means the reports from our integration tests won't over-write the reports from our unit tests.
tasks.withType(Test) {
    reports.html.destination = file("${reporting.baseDir}/${name}")
}

run {
    args 'server', './dev.yml'
}
